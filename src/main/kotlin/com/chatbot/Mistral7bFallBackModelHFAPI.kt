package com.chatbot

import io.github.cdimascio.dotenv.dotenv
import io.ktor.client.*
import io.ktor.client.engine.cio.*
import io.ktor.client.plugins.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.*



/**
 * * Class to handle the interaction with the Mistral7B model on HF Space
 *
 * 1. The code uses curl request in order to isolate the Thread used in Zephyr request,
 *    ...since it is blocking the fallback with a Zombie timeout.
 * 2. The code uses a retry mechanism to handle connection timeouts.
 *
 * **/
class Mistral7bFallBackModelHFAPI {

    private val token = dotenv()["HF_API_MISTRAL_KEY_TOKEN"]
    private val endpoint = "https://api-inference.huggingface.co/models/mistralai/Mistral-7B-Instruct-v0.3"

    fun callMistral7b(user_input: String): String {
        val customMessage = "❌ Sorry, Mistral7B is unavailable."

        val formated_user_input= buildPrompt(user_input)
        val requestBody = Json.encodeToString(buildJsonObject {
            put("inputs", formated_user_input)
        })
        return try {
            runBlocking {
                val client = HttpClient(CIO) {
                    install(HttpTimeout)
                }
                val response: HttpResponse = client.post(endpoint) {
                    contentType(ContentType.Application.Json)
                    headers {
                        append("Authorization", "Bearer $token")
                    }
                    setBody(requestBody)
                    timeout {
                        requestTimeoutMillis = 30000
                    }
                }

                val responseBody = response.bodyAsText()
                val parsed = Json.parseToJsonElement(responseBody)
                println("✅ Mistral7B HTTP Response: $responseBody")

                if (parsed is JsonArray && parsed.isNotEmpty()) {
                    val generatedText = parsed[0].jsonObject["generated_text"]?.jsonPrimitive?.content
                        ?: "⚠️ No generated text from Mistral."

                    val footer = "\n\n---\n_⚠\uFE0F This response was generated by fallback model Mistral7b v.3 after Zephyr timeout._"
                    cleanResponse(generatedText) + footer
                    // Clean output: Remove the prompt instructions from the response
                    cleanResponse(generatedText) + footer
                } else {
                    "⚠Unexpected Mistral response format: $responseBody"
                }
            }
        } catch (e: Exception) {
            println("❌ Mistral7B HttpClient Error: ${e.message}")
            e.printStackTrace()
            "$customMessage (${e.message})"
        }
    }

    private fun buildPrompt(userInput: String): String {
        val prompt = """
        ### Instruction:
        You are a helpful assistant. Your task is to provide a structured, high-quality answer to the user query following these guidelines:
        
        1. **Structure** your response with clear sections, using headings, lists, bold, italics, links, code and bullet points where appropriate.
        2. Start with a clear introduction of what your response is about
        3. Keep the tone **concise**, **professional**, and **easy to read**.
        4. Do **not repeat the question**.
        5. Avoid vague filler phrases like "it's a good idea" or "you may find that...".
        6. End with a short summary or conclusion if appropriate.
        7. Always provide a **farewell** text at the end of your response, such as "Feel free to ask if you have more questions!".
        
        
        ### User Query:
        $userInput

        ### Response:
    """.trimIndent()
        return prompt
    }

    private fun cleanResponse(response: String): String {
        // If the model repeats the prompt instructions, remove them by splitting on "### Response:" and taking only the answer part.
        val marker = "### Response:"
        return if (response.contains(marker)) {
            response.substringAfter(marker).trim()
        } else {
            response.trim()
        }
    }
}